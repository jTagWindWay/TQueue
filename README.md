# TQueue
Создание структуры хранения данных очередь

Содержание

Цель	3
Постановка задачи	3
Используемые инструменты	3
Общая структура проекта	3
Подробное описание модуля TQform	4
Подробное описание модуля test	6
Результаты тестов	9
Графическое представление	10
Заключение	13


 
Цель
В рамках лабораторной работы ставится задача создать шаблонный класс TQueue, работающий по принципу FIFO(first-in-first-out). Создать графическую интерпретацию класса TQueue в виде замкнутого кольца, которое по таймеру, каждый такт времени с некоторой вероятностью либо заполняется одним элементом, либо один элемент извлекается.
Постановка задачи
1.	Реализация шаблонного класса TQueue  и его методов.
2.	Создание тестов для класса TQueue  .
3.	Обеспечение работоспособности тестов.
4.	Создание графической интерпретации TQueue в Windows Form.

Используемые инструменты
•	Система контроля версий Git. 
•	Фреймворк для написания автоматических тестов Google Test. 
•	Среда разработки Microsoft Visual Studio 2015

Общая структура проекта
Структура проекта:
•	gtest — библиотека Google Test.
•	include — директория для размещения заголовочных файлов.
•	samples — директория для размещения тестового приложения.
•	sln — директория с файлами решений и проектов для VS 2008 и VS 2010, вложенные директории vc9 и vc10соответственно.
•	src — директория для размещения исходных кодов (cpp-файлы).
•	test — директория с модульными тестами и основным приложением, инициализирующим запуск тестов.
•	Служебные файлы
o	.gitignore — перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий.
В решении содержатся следующие модули:
•	Модуль TQform, содержащий MyForm и реализацию класса TQueue. (файлы ./TQueue/TQueue.h, .\TQueue\MyForm.h) 
•	Модуль test, содержащий тесты для класса TQueue (файлы ./test/test_TQueue.cpp, ./test/test_main.cpp).

Подробное описание модуля TQform
TQueue.h– содержит в себе реализацию шаблонного класса TQueue, работающий по принципу –первый-пришёл-первый-ушёл-.

Объявление класса TQueue и его поля
template <class T>
	 class TQueue {
		 int first - номер первого элемента очереди
		 int MaxSize – максимальный размер очереди
		 int Size – текущий размер очереди
		 int last – номер последнего элемента очереди
		 T * mas – массив шаблонных элементов очереди

Так как класс TQueue является шаблонным, то реализация его методов находится в том же файле, что и объявление класса.
	 public:


Реализация конструктора по умолчанию. При создании элемента, по умолчанию его максимальный размер будет 20, текущий размер 0, номер первого элемента 0, номер последнего элемента -1, произойдёт выделение памяти под массив шаблонных элементов mas.

		 TQueue(int _MaxSize = 20) {     
			 MaxSize = _MaxSize;
			 Size = 0;
			 mas = new T[MaxSize];
			 first = 0;
			 last = -1;     
		 }
		  

Реализация конструктора копирования. На вход константная ссылка на шаблонный элемент класса. В функции переопределяем свойства класса на текущее значение объекта.
                   
		 TQueue(const TQueue & tq) {        
	              MaxSize = tq.MaxSize;
			 Size = tq.Size;
			 mas = new T[MaxSize];
			 for (size_t i = 0; i < Size; i++) {
				 mas[i] = tq.mas[i];
			 }
			 first = tq.first;
			 last = tq.last;
		 }

Реализация функции проверки на пустоту. Если текущий размер равен 0, то правда, иначе ложь.

		 bool isEmpty() {                                  
			 if (Size == 0) return true;
			 else return false;
		 }


Реализация функции проверки на полноту. Если текущий размер равен максимальному, то правда, иначе ложь.

		 bool isFull() {
			 if (Size == MaxSize) return true;             
			 else return false;
		 }


Реализация функции положить элемент в очередь. На вход шаблонный элемент. Проверяем очередь на полноту, если очередь не полная, то увеличиваем номер последнего элемента 1 и добавляем туда новый элемент, затем увеличиваем текущий размер очереди.

		 void Push(T a) {                                 
			 if (isFull()) throw 1;
			 if (last == MaxSize - 1) last = 0;
			 else {
				 last++;
				 mas[last] = a;
				 Size++;
			 }
		 }

Реализация функции извлечения из очереди. Проверяем функцию на пустоту, если она не пустая, то создаём элемент а и присваиваем ему первую позицию в очереди. Если первый элемент это элемент перед максимальным размером, то первый элемент равен 0, иначе первый элемент увеличивается на 1, а текущий размер уменьшается на 1. Затем возвращаем элемент а.

		 T Pop() {
			 if (isEmpty()) throw 2;
			 T a = mas[first];
			 if (first == MaxSize - 1) first = 0;
			 else {
				 first++;
				 Size--;
			 }
			 return a;
		 }



Реализация перегрузки оператора присваивания. На вход подаётся константная ссылка на шаблонный элемент класса. Если размеры текущего объекта не равны. То приравневаемый объект очищается и создаётся равным тому, к которому он приравнивается. Затем происходит присваивание всех свойств объекта.

		 T & operator = (const T & tq) {                 
			 if (MaxSize != tq.MaxSize) {
				 delete[] mas;
				 MaxSize = tq.MaxSize;
				 Size = tq.Size;
				 mas = new T[MaxSize];
			 }
			 for (size_t i = 0; i < MaxSize; i++) {
				 mas[i] = tq.mas[i];
			 }
			 fitst = tq.first;
			 last = tq.last;
			 return *this;
		 }


Реализация функции доступа к первому элементу очереди

		 T GetFirst() {
			 return first;
		 }


Реализация функции доступа к максимальному размеру

		 T GetMaxSize() {
			 return MaxSize;
		 }


Реализация функции доступа к последнему элементу очереди

		 T GetLast() {
			 return last;
		 }


Реализация функции доступа к текущему размеру очереди

		 T GetSize() {
			 return Size;
		 }

 };




Подробное описание модуля test
test_main.cpp –  запускает все тесты.
test_TQueue.cpp  –  содержит тесты к классу TQueue.

Реализация тестов для класса TQueue в test_ TQueue.cpp

#include "..\TQueue\TQueue.h" - подключение класса TQueue

#include "gtest.h" – подключение Google Test библиотеки


Тест проверяет возможность создать очередь с положительным размером.

TEST(TQueue, can_create_TQueue_with_positive_length)
{
  ASSERT_NO_THROW(TQueue<int> ts(3));                    //ASSERT_NO_THROW (ОЖИДАНИЕ, ЧТО ИСКЛЮЧЕНИЕ НЕ ВЫЛЕЗЕТ
}                                                       //ASSER


Тест проверяет невозможность создания очереди с отрицательным размером.

TEST(TQueue, cannot_create_TQueue_with_negative_length)
{
	ASSERT_ANY_THROW(TQueue<int> ts(-3));
}



Тест проверяет невозможность взятия элемента из пустой очереди.

TEST(TQueue, vzyatie_is_pustogo_TQueue)
{
	TQueue<int>tq(0);
	ASSERT_ANY_THROW(tq.Pop());
}
 


Тест проверяет корректность функции извлечения объекта из очереди.

TEST(TQueue, vzyatie_elementa_is_TQueue)
{
	TQueue<int>tq(2);
	tq.Push(1);
	tq.Push(2);
	ASSERT_EQ(tq.Pop(),1);
}



Тест проверяет корректность функции добавления элемента в очередь.

TEST(TQueue, dobavit_element_in_TQueue)
{
	TQueue<int>tq(2);
	ASSERT_NO_THROW(tq.Push(1));
}




Тест проверяет невозможность добавления элемента к полной очереди.

TEST(TQueue, dobavit_element_in_FULL_TQueue)
{
	TQueue<int>tq(2);
	tq.Push(1);
	tq.Push(2);
	ASSERT_ANY_THROW(tq.Push(3));
}


Тест проверяет возможность создания новой очереди, путём копирования исходной.

TEST(TQueue, can_create_copied_TQueue)
{
	TQueue<int> m(5);
	ASSERT_NO_THROW(TQueue<int> m1(m));
}



Тест проверяет равенство двух очередей, одна из которых получена путём копирования другой. 

TEST(TQueue, copied_TQueue_is_equal_to_source_one)
{
	TQueue <int> m(4);
	m.Push(1);
	TQueue <int> m1(m);
	int a = m.Pop();
	int b = m1.Pop();
	EXPECT_EQ(a, b);
}



Тест проверяет то, что две очереди, одна из которых получена путём копирования другой, имеют разные области памяти.

TEST(TQueue, copied_TQueue_has_its_own_memory)
{
	TQueue<int> m1(4);
	TQueue<int> m2(4);

	m1.Push(1);
	m1.Push(2);

	m2.Push(1);
	m2.Push(2);
	EXPECT_FALSE(&m1 == &m2);
}


Тест проверяет оператор присваивания, примененный к очередям однинакового размера.

TEST(TQueue, can_ravenstvo_eleventov_with_equal_size_TQueue)
{
	TQueue<int>tq1(3);
	TQueue<int>tq2(3);
	tq1.Push(3);
	tq1.Push(2);
	tq2 = tq1;
	ASSERT_EQ(tq1.Pop(), tq2.Pop());
}



Тест проверяет оператор присваивания, примененный к очередям разного размера.

TEST(TQueue, can_ravenstvo_eleventov_with_non_equal_size_TQueue)
{
	TQueue<int>tq1(3);
	TQueue<int>tq2(5);
	tq1.Push(3);
	tq1.Push(2);
	tq2 = tq1;
	tq1.Pop();
	tq2.Pop();
	ASSERT_EQ(tq1.Pop(), tq2.Pop());
}



Проверка созданных тестов
Выше приведенные тесты прошли проверку:
 


Графическое представление

Создал форму, которая выглядит следующим образом:
 

При работе с данной формой:
В текст боксе MaxSize задаётся максимальный размер создаваемой очереди. 
Size отвечает за текущий размер очереди.
p – вероятность добавления элемента в очередь, если случайно сгенерированное число больше p, где p назначается в диапазоне от 0 до 100.
q – вероятность извлечения элемента из очереди, если случайно сгенерированное число меньше q, где q назначается в диапазоне от 0 до 100.
Кнопка Старт отвечает за создание очереди с заданными выше параметрами.
Кнопка Стоп останавливает процесс отрисовки очереди.
Кнопка Очистить отвечает за освобождение памяти текущей очереди.
В графе «Добавлено» подсчитывается количество добавленных элементов в очередь, в графе «извлечено» количество извлеченных.
В графе «добавлено в пустую» подсчитывается количество попыток извлечения элементов из пустой очереди, в графе «добавлено в полную» добавления в полную.
Если создать очередь с такими параметрами: MaxSize = 100, Size = 50, p = 51, q = 49. До на экране отрисуется очередь, представляющая собой кольцо, где красным цветом подкрашиваются занятые элементы. С каждым тактом времени, по таймеру, задаётся случайное число, которое, если больше p	, то добавляется в очередь новый элемент, и закрашивается на форме, если случайное число меньше q, то элемент извлекается, и закрашивается цветом формы. Вот так выглядит начальное положение формы:
 

Через время, когда вероятность добавления выше, чем вероятность извлечения, очередь начинает напоминать кольцо, которое иногда замыкается: 
 


Так будет выглядеть очередь через некоторое время, в которой вероятность извлечения элемента выше, чем добавления:
 


Заключение 
Выполнил поставленные задачи. Реализовал структуру хранения очередь. Создал для неё тесты, на основе Google Test фреймворка. Реализовал графическое представление очереди в виде кольца. Разместил программу на GitHub репозитории.

GitHub:  https://github.com/jTagWindWay/TQueue.git



